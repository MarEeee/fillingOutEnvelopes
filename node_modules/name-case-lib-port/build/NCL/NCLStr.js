'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @license Dual licensed under the MIT or GPL Version 2 licenses.
 * @package NameCaseLib
 */

var mb_substr = require('locutus/php/strings/substr');
var mb_strpos = require('locutus/php/strings/strpos');
var mb_strlen = require('locutus/php/strings/strlen');
var mb_strtolower = require('locutus/php/strings/strtolower');
var mb_strtoupper = require('locutus/php/strings/strtoupper');
var mb_strrpos = require('locutus/php/strings/strrpos');
var mb_split = require('locutus/php/strings/split');
var implode = require('locutus/php/strings/implode');

/**
 * Класс содержит функции для работы со строками, которые используются в NCLNameCaseLib
 * 
 * @author Андрей Чайка <bymer3@gmail.com>
 * @version 0.4.1
 * @package NameCaseLib
 */

var NCLStr = function () {
  function NCLStr() {
    _classCallCheck(this, NCLStr);
  }

  _createClass(NCLStr, null, [{
    key: 'substr',


    /**
     * Получить подстроку из строки
     * @param string $str строка
     * @param int $start начало подстроки
     * @param int $length длина подстроки
     * @return int подстрока 
     */
    value: function substr(str, start) {
      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var s = mb_substr(str, start, length, NCLStr.charset);
      if (s === false) s = '';
      return s;
    }

    /**
     * Поиск подстроки в строке
     * @param string $haystack строка, в которой искать
     * @param string $needle подстрока, которую нужно найти
     * @param int $offset начало поиска
     * @return int позиция подстроки в строке
     */

  }, {
    key: 'strpos',
    value: function strpos(haystack, needle) {
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      return mb_strpos(haystack, needle, offset, NCLStr.charset);
    }

    /**
     * Определение длины строки
     * @param string $str строка
     * @return int длина строки
     */

  }, {
    key: 'strlen',
    value: function strlen(str) {
      return mb_strlen(str, NCLStr.charset);
    }

    /**
     * Переводит строку в нижний регистр
     * @param string $str строка
     * @return string строка в нижнем регистре
     */

  }, {
    key: 'strtolower',
    value: function strtolower(str) {
      return mb_strtolower(str, NCLStr.charset);
    }

    /**
     * Переводит строку в верхний регистр
     * @param string $str строка
     * @return string строка в верхнем регистре
     */

  }, {
    key: 'strtoupper',
    value: function strtoupper(str) {
      return mb_strtoupper(str, NCLStr.charset);
    }

    /**
     * Поиск подстроки в строке справа
     * @param string $haystack строка, в которой искать
     * @param string $needle подстрока, которую нужно найти
     * @param int $offset начало поиска
     * @return int позиция подстроки в строке
     */

  }, {
    key: 'strrpos',
    value: function strrpos(haystack, needle) {
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      return mb_strrpos(haystack, needle, offset, NCLStr.charset);
    }

    /**
     * Проверяет в нижнем ли регистре находится строка
     * @param string $phrase строка
     * @return bool в нижнем ли регистре строка 
     */

  }, {
    key: 'isLowerCase',
    value: function isLowerCase(phrase) {
      return phrase == NCLStr.strtolower(phrase);
    }

    /**
    * Проверяет в верхнем ли регистре находится строка
    * @param string $phrase строка
    * @return bool в верхнем ли регистре строка 
    */

  }, {
    key: 'isUpperCase',
    value: function isUpperCase(phrase) {
      return phrase == NCLStr.strtoupper(phrase);
    }

    /**
     * Превращает строку в массив букв
     * @param string $phrase строка
     * @return array массив букв
     */

  }, {
    key: 'splitLetters',
    value: function splitLetters(phrase) {
      var resultArr = [];
      var stop = NCLStr.strlen(phrase);
      for (var idx = 0; idx < stop; idx++) {
        resultArr.push(NCLStr.substr(phrase, idx, 1));
      }
      return resultArr;
    }

    /**
     * Соединяет массив букв в строку
     * @param array $lettersArr массив букв
     * @return string строка
     */

  }, {
    key: 'connectLetters',
    value: function connectLetters(lettersArr) {
      return implode('', lettersArr);
    }

    /**
     * Разбивает строку на части использую шаблон
     * @param string $pattern шаблон разбития
     * @param string $string строка, которую нужно разбить
     * @return array разбитый массив 
     */

  }, {
    key: 'explode',
    value: function explode(pattern, string) {
      return mb_split(pattern, string);
    }
  }, {
    key: 'charset',

    /**
     * Кодировка, в котороя работает система
     * @var string 
     */
    get: function get() {
      return 'utf-8';
    }
  }]);

  return NCLStr;
}();

exports.default = NCLStr;