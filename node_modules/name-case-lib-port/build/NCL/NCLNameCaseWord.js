"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license Dual licensed under the MIT or GPL Version 2 licenses.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @package NameCaseLib
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _NCLStr = require("./NCLStr.js");

var _NCLStr2 = _interopRequireDefault(_NCLStr);

var _NCL = require("./NCL.js");

var _NCL2 = _interopRequireDefault(_NCL);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var math_min = require('locutus/php/math/min');
var math_max = require('locutus/php/math/max');

/**
 * NCLNameCaseWord - класс, который служит для хранения всей информации о каждом слове
 *
 * @author Андрей Чайка <bymer3@gmail.com>
 * @version 0.4.1
 * @package NameCaseLib
 */

var NCLNameCaseWord = function () {
    /**
     * Создание нового обьекта со словом <var>$word</var>
     * @param string $word слово
     */
    function NCLNameCaseWord(word) {
        _classCallCheck(this, NCLNameCaseWord);

        /**
         * Слово в нижнем регистре, которое хранится в об’єкте класса
         * @var string
         */
        this.word = '';
        /**
         * Оригинальное слово
         * @var string
         */
        this.word_orig = '';
        /**
         * Тип текущей записи (Фамилия/Имя/Отчество)
         * - <b>N</b> - ім’я
         * - <b>S</b> - прізвище
         * - <b>F</b> - по-батькові
         * @var string
         */
        this.namePart = null;
        /**
         * Вероятность того, что текущей слово относится к мужскому полу
         * @var int
         */
        this.genderMan = 0;
        /**
         * Вероятность того, что текущей слово относится к женскому полу
         * @var int
         */
        this.genderWoman = 0;
        /**
         * Окончательное решение, к какому полу относится слово
         * - 0 - не определено
         * - NCL::$MAN - мужской пол
         * - NCL::$WOMAN - женский пол
         * @var int
         */
        this.genderSolved = 0;
        /**
         * Маска больших букв в слове.
         *
         * Содержит информацию о том, какие буквы в слове были большими, а какие мальникими:
         * - x - маленькая буква
         * - X - больная буква
         * @var array
         */
        this.letterMask = [];
        /**
         * Содержит true, если все слово было в верхнем регистре и false, если не было
         * @var bool
         */
        this.isUpperCase = false;
        /**
         * Массив содержит все падежи слова, полученые после склонения текущего слова
         * @var array
         */
        this.NameCases = [];
        /**
         * Номер правила, по которому было произведено склонение текущего слова
         * @var int
         */
        this.rule = 0;

        this.word_orig = word;
        this.generateMask(word);
        this.word = _NCLStr2.default.strtolower(word);
    }

    /**
     * Генерирует маску, которая содержит информацию о том, какие буквы в слове были большими, а какие маленькими:
     * - x - маленькая буква
     * - X - больная буква
     * @param string $word слово, для которого генерировать маску
     */


    _createClass(NCLNameCaseWord, [{
        key: "generateMask",
        value: function generateMask(word) {
            var letters = _NCLStr2.default.splitLetters(word);
            var mask = [];
            this.isUpperCase = true;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = letters[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var letter = _step.value;

                    if (_NCLStr2.default.isLowerCase(letter)) {
                        mask.push('x');
                        this.isUpperCase = false;
                    } else {
                        mask.push('X');
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            this.letterMask = mask;
        }

        /**
         * Возвращает все падежи слова в начальную маску:
         * - x - маленькая буква
         * - X - больная буква
         */

    }, {
        key: "returnMask",
        value: function returnMask() {
            if (this.isUpperCase) {
                for (var index in this.NameCases) {
                    var kase = this.NameCases[index];
                    this.NameCases[index] = _NCLStr2.default.strtoupper(this.NameCases[index]);
                }
            } else {
                var splitedMask = this.letterMask;
                var maskLength = splitedMask.length;
                for (var index in this.NameCases) {
                    var kase = this.NameCases[index];
                    var caseLength = _NCLStr2.default.strlen(kase);
                    var max = math_min([caseLength, maskLength]);
                    this.NameCases[index] = '';
                    for (var letterIndex = 0; letterIndex < max; letterIndex++) {
                        var letter = _NCLStr2.default.substr(kase, letterIndex, 1);
                        if (splitedMask[letterIndex] == 'X') {
                            letter = _NCLStr2.default.strtoupper(letter);
                        }
                        this.NameCases[index] += letter;
                    }
                    this.NameCases[index] += _NCLStr2.default.substr(kase, max, caseLength - maskLength);
                }
            }
        }

        /**
         * Сохраняет результат склонения текущего слова
         * @param array $nameCases массив со всеми падежами
         */

    }, {
        key: "setNameCases",
        value: function setNameCases(nameCases) {
            var is_return_mask = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

            this.NameCases = nameCases;
            if (is_return_mask) this.returnMask();
        }

        /**
         * Возвращает массив со всеми падежами текущего слова
         * @return array массив со всеми падежами
         */

    }, {
        key: "getNameCases",
        value: function getNameCases() {
            return this.NameCases;
        }

        /**
         * Возвращает строку с нужным падежом текущего слова
         * @param int $number нужный падеж
         * @return string строка с нужным падежом текущего слова
         */

    }, {
        key: "getNameCase",
        value: function getNameCase(number) {
            if (this.NameCases[number] != undefined) {
                return this.NameCases[number];
            }
            return false;
        }

        /**
         * Расчитывает и возвращает пол текущего слова
         * @return int пол текущего слова
         */

    }, {
        key: "gender",
        value: function gender() {
            if (!this.genderSolved) {
                if (this.genderMan >= this.genderWoman) {
                    this.genderSolved = _NCL2.default.$MAN;
                } else {
                    this.genderSolved = _NCL2.default.$WOMAN;
                }
            }
            return this.genderSolved;
        }

        /**
         * Устанавливает вероятности того, что даное слово является мужчиной или женщиной
         * @param int $man вероятность того, что слово мужчина
         * @param int $woman верятность того, что слово женщина
         */

    }, {
        key: "setGender",
        value: function setGender(man, woman) {
            this.genderMan = man;
            this.genderWoman = woman;
        }

        /**
         * Окончательно устанавливает пол человека
         * - 0 - не определено
         * - NCL::$MAN - мужчина
         * - NCL::$WOMAN - женщина
         * @param int $gender пол человека
         */

    }, {
        key: "setTrueGender",
        value: function setTrueGender(gender) {
            this.genderSolved = gender;
        }

        /**
         * Возвращает массив вероятности того, что даное слово является мужчиной или женщиной
         * @return array массив вероятностей
         */

    }, {
        key: "getGender",
        value: function getGender() {
            var _ref;

            return _ref = {}, _defineProperty(_ref, _NCL2.default.MAN, this.genderMan), _defineProperty(_ref, _NCL2.default.WOMAN, this.genderWoman), _ref;
        }

        /**
         * Устанавливает тип текущего слова
         * <b>Тип слова:</b>
         * - S - Фамилия
         * - N - Имя
         * - F - Отчество
         * @param string $namePart тип слова
         */

    }, {
        key: "setNamePart",
        value: function setNamePart(namePart) {
            this.namePart = namePart;
        }

        /**
         * Возвращает тип текущего слова
         * <b>Тип слова:</b>
         * - S - Фамилия
         * - N - Имя
         * - F - Отчество
         * @return string $namePart тип слова
         */

    }, {
        key: "getNamePart",
        value: function getNamePart() {
            return this.namePart;
        }

        /**
         * Возвращает текущее слово.
         * @return string текущее слово
         */

    }, {
        key: "getWord",
        value: function getWord() {
            return this.word;
        }

        /**
         * Возвращает текущее оригинальное слово.
         * @return string текущее слово
         */

    }, {
        key: "getWordOrig",
        value: function getWordOrig() {
            return this.word_orig;
        }

        /**
         * Если уже был расчитан пол для всех слов системы, тогда каждому слову предается окончательное
         * решение. Эта функция определяет было ли принято окончательное решение.
         * @return bool было ли принято окончательное решение по поводу пола текущего слова
         */

    }, {
        key: "isGenderSolved",
        value: function isGenderSolved() {
            return this.genderSolved ? true : false;
        }

        /**
         * Устанавливает номер правила по которому склонялось текущее слово.
         * @param int $ruleID номер правила
         */

    }, {
        key: "setRule",
        value: function setRule(ruleID) {
            this.rule = ruleID;
        }
    }]);

    return NCLNameCaseWord;
}();

exports.default = NCLNameCaseWord;