'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NCL2 = require('./NCL.js');

var _NCL3 = _interopRequireDefault(_NCL2);

var _NCLStr = require('./NCLStr.js');

var _NCLStr2 = _interopRequireDefault(_NCLStr);

var _NCLNameCaseWord = require('./NCLNameCaseWord.js');

var _NCLNameCaseWord2 = _interopRequireDefault(_NCLNameCaseWord);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license Dual licensed under the MIT or GPL Version 2 licenses.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @package NameCaseLib
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var math_min = require('locutus/php/math/min');
var math_max = require('locutus/php/math/max');
var mb_strtolower = require('locutus/php/strings/strtolower');
var explode = require('locutus/php/strings/explode');
var implode = require('locutus/php/strings/implode');
var trim = require('locutus/php/strings/trim');
var is_null = require('locutus/php/var/is_null');
var is_array = require('locutus/php/var/is_array');
var array_fill = require('locutus/php/array/array_fill');
var in_array = require('locutus/php/array/in_array');
var array_key_exists = require('locutus/php/array/array_key_exists'),
    key_exists = array_key_exists;

/**
 * <b>NCL NameCase Core</b>
 *
 * Набор основных функций, который позволяют сделать интерфейс слонения русского и украниского языка
 * абсолютно одинаковым. Содержит все функции для внешнего взаимодействия с библиотекой.
 *
 * @author Андрей Чайка <bymer3@gmail.com>
 * @version 0.4.1
 * @package NameCaseLib
 */

var NCLNameCaseCore = function (_NCL) {
    _inherits(NCLNameCaseCore, _NCL);

    function NCLNameCaseCore() {
        _classCallCheck(this, NCLNameCaseCore);

        /**
         * Версия библиотеки
         * @var string
         */
        var _this = _possibleConstructorReturn(this, (NCLNameCaseCore.__proto__ || Object.getPrototypeOf(NCLNameCaseCore)).call(this));

        _this._version = '0.4.1';
        /**
         * Версия языкового файла
         * @var string
         */
        _this._languageBuild = '0';
        /**
         * Готовность системы:
         * - Все слова идентифицированы (известо к какой части ФИО относится слово)
         * - У всех слов определен пол
         * Если все сделано стоит флаг true, при добавлении нового слова флаг сбрасывается на false
         * @var bool
         */
        _this.ready = false;
        /**
         * Если все текущие слова было просклонены и в каждом слове уже есть результат склонения,
         * тогда true. Если было добавлено новое слово флаг збрасывается на false
         * @var bool
         */
        _this.finished = false;
        /**
         * Массив содержит елементы типа NCLNameCaseWord. Это все слова которые нужно обработать и просклонять
         * @var array
         */
        _this.words = [];
        /**
         * Переменная, в которую заносится слово с которым сейчас идет работа
         * @var string
         */
        _this.workingWord = '';
        /**
         * Метод Last() вырезает подстроки разной длины. Посколько одинаковых вызовов бывает несколько,
         * то все результаты выполнения кешируются в этом массиве.
         * @var array
         */
        _this.workindLastCache = [];
        /**
         * Номер последнего использованого правила, устанавливается методом Rule()
         * @var int
         */
        _this.lastRule = 0;
        /**
         * Массив содержит результат склонения слова - слово во всех падежах
         * @var array
         */
        _this.lastResult = [];
        /**
         * Массив содержит информацию о том какие слова из массива <var>$this->words</var> относятся к
         * фамилии, какие к отчеству а какие к имени. Массив нужен потому, что при добавлении слов мы не
         * всегда знаем какая часть ФИО сейчас, поэтому после идентификации всех слов генерируется массив
         * индексов для быстрого поиска в дальнейшем.
         * @var array
         */
        _this.index = {};

        _this.gender_koef = 0; //вероятность автоопредления пола [0..10]. Достаточно точно при 0.1
        return _this;
    }

    /**
     * Метод очищает результаты последнего склонения слова. Нужен при склонении нескольких слов.
     */


    _createClass(NCLNameCaseCore, [{
        key: 'reset',
        value: function reset() {
            this.lastRule = 0;
            this.lastResult = [];
        }

        /**
         * Сбрасывает все информацию на начальную. Очищает все слова добавленые в систему.
         * После выполнения система готова работать с начала.
         * @return NCLNameCaseCore
         */

    }, {
        key: 'fullReset',
        value: function fullReset() {
            this.words = [];
            this.index = { 'N': [], 'F': [], 'S': [] };
            this.reset();
            this.notReady();
            return this;
        }
    }, {
        key: 'notReady',


        /**
         * Устанавливает флаги о том, что система не готово и слова еще не были просклонены
         */
        value: function notReady() {
            this.ready = false;
            this.finished = false;
        }

        /**
         * Устанавливает номер последнего правила
         * @param int $index номер правила которое нужно установить
         */

    }, {
        key: 'Rule',
        value: function Rule(index) {
            this.lastRule = index;
        }

        /**
         * Устанавливает слово текущим для работы системы. Очищает кеш слова.
         * @param string $word слово, которое нужно установить
         */

    }, {
        key: 'setWorkingWord',
        value: function setWorkingWord(word) {
            //Сбрасываем настройки
            this.reset();
            //Ставим слово
            this.workingWord = word;
            //Чистим кеш
            this.workindLastCache = [];
        }

        /**
         * Если не нужно склонять слово, делает результат таким же как и именительный падеж
         */

    }, {
        key: 'makeResultTheSame',
        value: function makeResultTheSame() {
            this.lastResult = array_fill(0, this.CaseCount, this.workingWord);
        }

        /**
         * Если <var>$stopAfter</var> = 0, тогда вырезает $length последних букв с текущего слова (<var>$this->workingWord</var>)
         * Если нет, тогда вырезает <var>$stopAfter</var> букв начиная от <var>$length</var> с конца
         * @param int $length количество букв с конца
         * @param int $stopAfter количество букв которые нужно вырезать (0 - все)
         * @return string требуемая подстрока
         */

    }, {
        key: 'Last',
        value: function Last() {
            var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var stopAfter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            //Сколько букв нужно вырезать все или только часть
            if (!stopAfter) {
                var cut = length;
            } else {
                cut = stopAfter;
            }

            //Проверяем кеш
            if (this.workindLastCache[length] == undefined) this.workindLastCache[length] = [];
            if (this.workindLastCache[length][stopAfter] == undefined) {
                this.workindLastCache[length][stopAfter] = _NCLStr2.default.substr(this.workingWord, -length, cut);
            }
            return this.workindLastCache[length][stopAfter];
        }

        /**
         * Над текущим словом (<var>$this->workingWord</var>) выполняются правила в порядке указаном в <var>$rulesArray</var>.
         * <var>$gender</var> служит для указания какие правила использовать мужские ('man') или женские ('woman')
         * @param string $gender - префикс мужских/женских правил
         * @param array $rulesArray - массив, порядок выполнения правил
         * @return boolean если правило было задествовано, тогда true, если нет - тогда false
         */

    }, {
        key: 'RulesChain',
        value: function RulesChain(gender, rulesArray) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = rulesArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var ruleID = _step.value;

                    var ruleMethod = gender + 'Rule' + ruleID;
                    if (typeof this[ruleMethod] != 'function') throw new Exception("Method " + ruleMethod + " not found");
                    if (this[ruleMethod]()) {
                        return true;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return false;
        }

        /**
         * Если <var>$string</var> строка, тогда проверяется входит ли буква <var>$letter</var> в строку <var>$string</var>
         * Если <var>$string</var> массив, тогда проверяется входит ли строка <var>$letter</var> в массив <var>$string</var>
         * @param string $letter буква или строка, которую нужно искать
         * @param mixed $string строка или массив, в котором нужно искать
         * @return bool true если искомое значение найдено
         */

    }, {
        key: 'in',
        value: function _in(letter, string) {
            //Если второй параметр массив
            if (is_array(string)) {
                return in_array(letter, string);
            } else {
                if (!letter || _NCLStr2.default.strpos(string, letter) === false) {
                    return false;
                } else {
                    return true;
                }
            }
        }

        /**
         * Функция проверяет, входит ли имя <var>$nameNeedle</var> в перечень имен <var>$names</var>.
         * @param string $nameNeedle - имя которое нужно найти
         * @param array $names - перечень имен в котором нужно найти имя
         */

    }, {
        key: 'inNames',
        value: function inNames(nameNeedle, names) {
            if (!is_array(names)) {
                names = [names];
            }

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = names[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var name = _step2.value;

                    if (_NCLStr2.default.strtolower(nameNeedle) == _NCLStr2.default.strtolower(name)) {
                        return true;
                    }
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            return false;
        }

        /**
         * Склоняет слово <var>$word</var>, удаляя из него <var>$replaceLast</var> последних букв
         * и добавляя в каждый падеж окончание из массива <var>$endings</var>.
         * @param string $word слово, к которому нужно добавить окончания
         * @param array $endings массив окончаний
         * @param int $replaceLast сколько последних букв нужно убрать с начального слова
         */

    }, {
        key: 'wordForms',
        value: function wordForms(word, endings) {
            var replaceLast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

            //Создаем массив с именительный падежом
            var result = [this.workingWord];
            //Убираем в окончание лишние буквы
            word = _NCLStr2.default.substr(word, 0, _NCLStr2.default.strlen(word) - replaceLast);

            //Добавляем окончания
            for (var padegIndex = 1; padegIndex < this.CaseCount; padegIndex++) {
                result[padegIndex] = word + endings[padegIndex - 1];
            }

            this.lastResult = result;
        }

        /**
         * В массив <var>$this->words</var> добавляется новый об’єкт класса NCLNameCaseWord
         * со словом <var>$firstname</var> и пометкой, что это имя
         * @param string $firstname имя
         * @return NCLNameCaseCore
         */

    }, {
        key: 'setFirstName',
        value: function setFirstName() {
            var firstname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            if (firstname) {
                var newWord = new _NCLNameCaseWord2.default(firstname);
                newWord.setNamePart('N');
                this.words.push(newWord);
                this.notReady();
            }
            return this;
        }

        /**
         * В массив <var>$this->words</var> добавляется новый об’єкт класса NCLNameCaseWord
         * со словом <var>$secondname</var> и пометкой, что это фамилия
         * @param string $secondname фамилия
         * @return NCLNameCaseCore
         */

    }, {
        key: 'setSecondName',
        value: function setSecondName() {
            var secondname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            if (secondname) {
                var newWord = new _NCLNameCaseWord2.default(secondname);
                newWord.setNamePart('S');
                this.words.push(newWord);
                this.notReady();
            }
            return this;
        }

        /**
         * В массив <var>$this->words</var> добавляется новый об’єкт класса NCLNameCaseWord
         * со словом <var>$fathername</var> и пометкой, что это отчество
         * @param string $fathername отчество
         * @return NCLNameCaseCore
         */

    }, {
        key: 'setFatherName',
        value: function setFatherName() {
            var fathername = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            if (fathername) {
                var newWord = new _NCLNameCaseWord2.default(fathername);
                newWord.setNamePart('F');
                this.words.push(newWord);
                this.notReady();
            }
            return this;
        }

        /**
         * Всем словам устанавливается пол, который может иметь следующие значения
         * - 0 - не определено
         * - NCL::$MAN - мужчина
         * - NCL::$WOMAN - женщина
         * @param int $gender пол, который нужно установить
         * @return NCLNameCaseCore
         */

    }, {
        key: 'setGender',
        value: function setGender() {
            var gender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = this.words[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var word = _step3.value;

                    word.setTrueGender(gender);
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            return this;
        }

        /**
         * В система заносится сразу фамилия, имя, отчество
         * @param string $secondName фамилия
         * @param string $firstName имя
         * @param string $fatherName отчество
         * @return NCLNameCaseCore
         */

    }, {
        key: 'setFullName',
        value: function setFullName() {
            var secondName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var firstName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
            var fatherName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

            this.setFirstName(firstName);
            this.setSecondName(secondName);
            this.setFatherName(fatherName);
            return this;
        }

        /**
         * В массив <var>$this->words</var> добавляется новый об’єкт класса NCLNameCaseWord
         * со словом <var>$firstname</var> и пометкой, что это имя
         * @param string $firstname имя
         * @return NCLNameCaseCore
         */

    }, {
        key: 'setName',
        value: function setName() {
            var firstname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            return this.setFirstName(firstname);
        }

        /**
         * В массив <var>$this->words</var> добавляется новый об’єкт класса NCLNameCaseWord
         * со словом <var>$secondname</var> и пометкой, что это фамилия
         * @param string $secondname фамилия
         * @return NCLNameCaseCore
         */

    }, {
        key: 'setLastName',
        value: function setLastName() {
            var secondname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            return this.setSecondName(secondname);
        }

        /**
         * В массив <var>$this->words</var> добавляется новый об’єкт класса NCLNameCaseWord
         * со словом <var>$secondname</var> и пометкой, что это фамилия
         * @param string $secondname фамилия
         * @return NCLNameCaseCore
         */

    }, {
        key: 'setSirName',
        value: function setSirName() {
            var secondname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            return this.setSecondName(secondname);
        }

        /**
         * Если слово <var>$word</var> не идентифицировано, тогда определяется это имя, фамилия или отчество
         * @param NCLNameCaseWord $word слово которое нужно идентифицировать
         */

    }, {
        key: 'prepareNamePart',
        value: function prepareNamePart( /*NCLNameCaseWord*/word) {
            if (!(word instanceof _NCLNameCaseWord2.default)) throw new Exception("word should be of class NCLNameCaseWord");

            if (!word.getNamePart()) {
                this.detectNamePart(word);
            }
        }

        /**
         * Проверяет все ли слова идентифицированы, если нет тогда для каждого определяется это имя, фамилия или отчество
         */

    }, {
        key: 'prepareAllNameParts',
        value: function prepareAllNameParts() {
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
                for (var _iterator4 = this.words[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var word = _step4.value;

                    this.prepareNamePart(word);
                }
            } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                        _iterator4.return();
                    }
                } finally {
                    if (_didIteratorError4) {
                        throw _iteratorError4;
                    }
                }
            }
        }

        /**
         * Определяет пол для слова <var>$word</var>
         * @param NCLNameCaseWord $word слово для которого нужно определить пол
         */

    }, {
        key: 'prepareGender',
        value: function prepareGender( /*NCLNameCaseWord*/word) {
            if (!(word instanceof _NCLNameCaseWord2.default)) throw new Exception("word should be of class NCLNameCaseWord");

            if (!word.isGenderSolved()) {
                var namePart = word.getNamePart();
                switch (namePart) {
                    case 'N':
                        this.GenderByFirstName(word);
                        break;
                    case 'F':
                        this.GenderByFatherName(word);
                        break;
                    case 'S':
                        this.GenderBySecondName(word);
                        break;
                }
            }
        }

        /**
         * Для всех слов проверяет определен ли пол, если нет - определяет его
         * После этого расчитывает пол для всех слов и устанавливает такой пол всем словам
         * @return bool был ли определен пол
         */

    }, {
        key: 'solveGender',
        value: function solveGender() {
            //Ищем, может гдето пол уже установлен
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
                for (var _iterator5 = this.words[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                    var word = _step5.value;

                    if (word.isGenderSolved()) {
                        this.setGender(word.gender());
                        return true;
                    }
                }

                //Если нет тогда определяем у каждого слова и потом сумируем
            } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion5 && _iterator5.return) {
                        _iterator5.return();
                    }
                } finally {
                    if (_didIteratorError5) {
                        throw _iteratorError5;
                    }
                }
            }

            var man = 0;
            var woman = 0;

            var _iteratorNormalCompletion6 = true;
            var _didIteratorError6 = false;
            var _iteratorError6 = undefined;

            try {
                for (var _iterator6 = this.words[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                    var word = _step6.value;

                    this.prepareGender(word);
                    var gender = word.getGender();
                    man += gender[_NCL3.default.MAN];
                    woman += gender[_NCL3.default.WOMAN];
                }
            } catch (err) {
                _didIteratorError6 = true;
                _iteratorError6 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion6 && _iterator6.return) {
                        _iterator6.return();
                    }
                } finally {
                    if (_didIteratorError6) {
                        throw _iteratorError6;
                    }
                }
            }

            if (man > woman) {
                this.setGender(_NCL3.default.MAN);
            } else {
                this.setGender(_NCL3.default.WOMAN);
            }

            return true;
        }

        /**
         * Генерируется массив, который содержит информацию о том какие слова из массива <var>$this->words</var> относятся к
         * фамилии, какие к отчеству а какие к имени. Массив нужен потому, что при добавлении слов мы не
         * всегда знаем какая часть ФИО сейчас, поэтому после идентификации всех слов генерируется массив
         * индексов для быстрого поиска в дальнейшем.
         */

    }, {
        key: 'generateIndex',
        value: function generateIndex() {
            this.index = { 'N': [], 'S': [], 'F': [] };
            for (var index in this.words) {
                var word = this.words[index];
                var namepart = word.getNamePart();
                this.index[namepart].push(index);
            }
        }

        /**
         * Выполнет все необходимые подготовления для склонения.
         * Все слова идентфицируются. Определяется пол.
         * Обновляется индекс.
         */

    }, {
        key: 'prepareEverything',
        value: function prepareEverything() {
            if (!this.ready) {
                this.prepareAllNameParts();
                this.solveGender();
                this.generateIndex();
                this.ready = true;
            }
        }

        /**
         * По указаным словам определяется пол человека:
         * - 0 - не определено
         * - NCL::$MAN - мужчина
         * - NCL::$WOMAN - женщина
         * @return int текущий пол человека
         */

    }, {
        key: 'genderAutoDetect',
        value: function genderAutoDetect() {
            this.prepareEverything();

            if (!this.words.length) {
                var n = -1;
                var max_koef = -1;
                for (var k in this.words) {
                    var word = this.words[k];
                    var genders = word.getGender();
                    var min = math_min(genders);
                    var max = math_max(genders);
                    var koef = max - min;
                    if (koef > max_koef) {
                        max_koef = koef;
                        n = k;
                    }
                }

                if (n >= 0) {
                    if (this.words[n]) {
                        genders = this.words[n].getGender();
                        min = math_min(genders);
                        max = math_max(genders);
                        this.gender_koef = max - min;

                        return this.words[n].gender();
                    }
                }
            }
            return false;
        }

        /**
         * Разбивает строку <var>$fullname</var> на слова и возвращает формат в котором записано имя
         * <b>Формат:</b>
         * - S - Фамилия
         * - N - Имя
         * - F - Отчество
         * @param string $fullname строка, для которой необходимо определить формат
         * @return array формат в котором записано имя массив типа <var>$this->words</var>
         */

    }, {
        key: 'splitFullName',
        value: function splitFullName(fullname) {
            fullname = trim(fullname);
            var list = explode(' ', fullname);

            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
                for (var _iterator7 = list[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                    var word = _step7.value;

                    this.words.push(new _NCLNameCaseWord2.default(word));
                }
            } catch (err) {
                _didIteratorError7 = true;
                _iteratorError7 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion7 && _iterator7.return) {
                        _iterator7.return();
                    }
                } finally {
                    if (_didIteratorError7) {
                        throw _iteratorError7;
                    }
                }
            }

            this.prepareEverything();
            var formatArr = [];

            var _iteratorNormalCompletion8 = true;
            var _didIteratorError8 = false;
            var _iteratorError8 = undefined;

            try {
                for (var _iterator8 = this.words[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                    var word = _step8.value;

                    formatArr.push(word.getNamePart());
                }
            } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion8 && _iterator8.return) {
                        _iterator8.return();
                    }
                } finally {
                    if (_didIteratorError8) {
                        throw _iteratorError8;
                    }
                }
            }

            return this.words;
        }

        /**
         * Разбивает строку <var>$fullname</var> на слова и возвращает формат в котором записано имя
         * <b>Формат:</b>
         * - S - Фамилия
         * - N - Имя
         * - F - Отчество
         * @param string $fullname строка, для которой необходимо определить формат
         * @return string формат в котором записано имя
         */

    }, {
        key: 'getFullNameFormat',
        value: function getFullNameFormat(fullname) {
            this.fullReset();
            var words = this.splitFullName(fullname);
            var format = '';
            var _iteratorNormalCompletion9 = true;
            var _didIteratorError9 = false;
            var _iteratorError9 = undefined;

            try {
                for (var _iterator9 = words[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                    var word = _step9.value;

                    format += word.getNamePart() + ' ';
                }
            } catch (err) {
                _didIteratorError9 = true;
                _iteratorError9 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion9 && _iterator9.return) {
                        _iterator9.return();
                    }
                } finally {
                    if (_didIteratorError9) {
                        throw _iteratorError9;
                    }
                }
            }

            return format;
        }

        /**
         * Склоняет слово <var>$word</var> по нужным правилам в зависимости от пола и типа слова
         * @param NCLNameCaseWord $word слово, которое нужно просклонять
         */

    }, {
        key: 'WordCase',
        value: function WordCase( /*NCLNameCaseWord*/word) {
            if (!(word instanceof _NCLNameCaseWord2.default)) throw new Exception("word should be of class NCLNameCaseWord");

            var gender = word.gender() == _NCL3.default.MAN ? 'man' : 'woman';

            var namepart = '';

            var name_part_letter = word.getNamePart();
            switch (name_part_letter) {
                case 'F':
                    namepart = 'Father';
                    break;
                case 'N':
                    namepart = 'First';
                    break;
                case 'S':
                    namepart = 'Second';
                    break;
            }

            var method = gender + namepart + 'Name';
            if (typeof this[method] != 'function') throw new Exception("Method " + method + " not found");

            //если фамилия из 2х слов через дефис
            //http://new.gramota.ru/spravka/buro/search-answer?s=273912

            //рабоиваем слово с дефисами на части
            var tmp = word.getWordOrig();
            var cur_words = explode('-', tmp);
            var o_cur_words = [];

            var result = {};
            var last_rule = -1;

            var cnt = cur_words.length;
            for (var k in cur_words) {
                var cur_word = cur_words[k];
                var is_norm_rules = true;

                var o_ncw = new _NCLNameCaseWord2.default(cur_word);
                if (name_part_letter == 'S' && cnt > 1 && k < cnt - 1) {
                    //если первая часть фамилии тоже фамилия, то склоняем по общим правилам
                    //иначе не склоняется

                    var exclusion = ['тулуз']; //исключения
                    var cur_word_ = mb_strtolower(cur_word);
                    if (!in_array(cur_word_, exclusion)) {
                        var cls = _NCL3.default.getConcreteClass('ru');
                        var o_nc = new cls();
                        o_nc.detectNamePart(o_ncw);
                        is_norm_rules = o_ncw.getNamePart() == 'S';
                    } else {
                        is_norm_rules = false;
                    }
                }

                this.setWorkingWord(cur_word);

                if (is_norm_rules && this[method]()) {
                    //склоняется
                    var result_tmp = this.lastResult;
                    last_rule = this.lastRule;
                } else {
                    //не склоняется. Заполняем что есть
                    result_tmp = array_fill(0, this.CaseCount, cur_word);
                    last_rule = -1;
                }
                o_ncw.setNameCases(result_tmp);
                o_cur_words.push(o_ncw);
            }

            //объединение пачку частей слова в одно слово по каждому падежу
            var _iteratorNormalCompletion10 = true;
            var _didIteratorError10 = false;
            var _iteratorError10 = undefined;

            try {
                for (var _iterator10 = o_cur_words[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                    var o_ncw = _step10.value;

                    var namecases = o_ncw.getNameCases();
                    for (var k in namecases) {
                        var namecase = namecases[k];
                        if (key_exists(k, result)) result[k] = result[k] + '-' + namecase;else result[k] = namecase;
                    }
                }

                //устанавливаем падежи для целого слова
            } catch (err) {
                _didIteratorError10 = true;
                _iteratorError10 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion10 && _iterator10.return) {
                        _iterator10.return();
                    }
                } finally {
                    if (_didIteratorError10) {
                        throw _iteratorError10;
                    }
                }
            }

            word.setNameCases(result, false);
            word.setRule(last_rule);
        }

        /**
         * Производит склонение всех слов, который хранятся в массиве <var>$this->words</var>
         */

    }, {
        key: 'AllWordCases',
        value: function AllWordCases() {
            if (!this.finished) {
                this.prepareEverything();

                var _iteratorNormalCompletion11 = true;
                var _didIteratorError11 = false;
                var _iteratorError11 = undefined;

                try {
                    for (var _iterator11 = this.words[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
                        var word = _step11.value;

                        this.WordCase(word);
                    }
                } catch (err) {
                    _didIteratorError11 = true;
                    _iteratorError11 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion11 && _iterator11.return) {
                            _iterator11.return();
                        }
                    } finally {
                        if (_didIteratorError11) {
                            throw _iteratorError11;
                        }
                    }
                }

                this.finished = true;
            }
        }

        /**
         * Если указан номер падежа <var>$number</var>, тогда возвращается строка с таким номером падежа,
         * если нет, тогда возвращается массив со всеми падежами текущего слова.
         * @param NCLNameCaseWord $word слово для котрого нужно вернуть падеж
         * @param int $number номер падежа, который нужно вернуть
         * @return mixed массив или строка с нужным падежом
         */

    }, {
        key: 'getWordCase',
        value: function getWordCase( /*NCLNameCaseWord*/word) {
            var number = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            if (!(word instanceof _NCLNameCaseWord2.default)) throw new Exception("word should be of class NCLNameCaseWord");

            var cases = word.getNameCases();
            if (is_null(number) || number < 0 || number > this.CaseCount - 1) {
                return cases;
            } else {
                return cases[number];
            }
        }

        /**
         * Если нужно было просклонять несколько слов, то их необходимо собрать в одну строку.
         * Эта функция собирает все слова указаные в <var>$indexArray</var>  в одну строку.
         * @param array $indexArray индексы слов, которые необходимо собрать вместе
         * @param int $number номер падежа
         * @return mixed либо массив со всеми падежами, либо строка с одним падежом
         */

    }, {
        key: 'getCasesConnected',
        value: function getCasesConnected(indexArray) {
            var number = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            var readyArr = {};
            var _iteratorNormalCompletion12 = true;
            var _didIteratorError12 = false;
            var _iteratorError12 = undefined;

            try {
                for (var _iterator12 = indexArray[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                    var index = _step12.value;

                    readyArr.push(getWordCase(words[index], number));
                }
            } catch (err) {
                _didIteratorError12 = true;
                _iteratorError12 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion12 && _iterator12.return) {
                        _iterator12.return();
                    }
                } finally {
                    if (_didIteratorError12) {
                        throw _iteratorError12;
                    }
                }
            }

            var all = readyArr.length;
            if (all) {
                if (is_array(readyArr[0])) {
                    //Масив нужно скелить каждый падеж
                    var resultArr = [];
                    for (var kase = 0; kase < this.CaseCount; kase++) {
                        var tmp = {};
                        for (var i = 0; i < all; i++) {
                            tmp.push(readyArr[i][kase]);
                        }
                        resultArr[kase] = implode(' ', tmp);
                    }
                    return resultArr;
                } else {
                    return implode(' ', readyArr);
                }
            }
            return '';
        }

        /**
         * Функция ставит имя в нужный падеж.
         *
         * Если указан номер падежа <var>$number</var>, тогда возвращается строка с таким номером падежа,
         * если нет, тогда возвращается массив со всеми падежами текущего слова.
         * @param int $number номер падежа
         * @return mixed массив или строка с нужным падежом
         */

    }, {
        key: 'getFirstNameCase',
        value: function getFirstNameCase() {
            var number = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            this.AllWordCases();

            return this.getCasesConnected(this.index['N'], number);
        }

        /**
         * Функция ставит фамилию в нужный падеж.
         *
         * Если указан номер падежа <var>$number</var>, тогда возвращается строка с таким номером падежа,
         * если нет, тогда возвращается массив со всеми падежами текущего слова.
         * @param int $number номер падежа
         * @return mixed массив или строка с нужным падежом
         */

    }, {
        key: 'getSecondNameCase',
        value: function getSecondNameCase() {
            var number = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            this.AllWordCases();

            return this.getCasesConnected(this.index['S'], number);
        }

        /**
         * Функция ставит отчество в нужный падеж.
         *
         * Если указан номер падежа <var>$number</var>, тогда возвращается строка с таким номером падежа,
         * если нет, тогда возвращается массив со всеми падежами текущего слова.
         * @param int $number номер падежа
         * @return mixed массив или строка с нужным падежом
         */

    }, {
        key: 'getFatherNameCase',
        value: function getFatherNameCase() {
            var number = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            this.AllWordCases();

            return this.getCasesConnected(this.index['F'], number);
        }

        /**
         * Функция ставит имя <var>$firstName</var> в нужный падеж <var>$CaseNumber</var> по правилам пола <var>$gender</var>.
         *
         * Если указан номер падежа <var>$CaseNumber</var>, тогда возвращается строка с таким номером падежа,
         * если нет, тогда возвращается массив со всеми падежами текущего слова.
         * @param string $firstName имя, которое нужно просклонять
         * @param int $CaseNumber номер падежа
         * @param int $gender пол, который нужно использовать
         * @return mixed массив или строка с нужным падежом
         */

    }, {
        key: 'qFirstName',
        value: function qFirstName(firstName) {
            var CaseNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var gender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

            this.fullReset();
            this.setFirstName(firstName);
            if (gender) {
                this.setGender(gender);
            }
            return this.getFirstNameCase(CaseNumber);
        }

        /**
         * Функция ставит фамилию <var>$secondName</var> в нужный падеж <var>$CaseNumber</var> по правилам пола <var>$gender</var>.
         *
         * Если указан номер падежа <var>$CaseNumber</var>, тогда возвращается строка с таким номером падежа,
         * если нет, тогда возвращается массив со всеми падежами текущего слова.
         * @param string $secondName фамилия, которую нужно просклонять
         * @param int $CaseNumber номер падежа
         * @param int $gender пол, который нужно использовать
         * @return mixed массив или строка с нужным падежом
         */

    }, {
        key: 'qSecondName',
        value: function qSecondName(secondName) {
            var CaseNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var gender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

            this.fullReset();
            this.setSecondName(secondName);
            if (gender) {
                this.setGender(gender);
            }

            return this.getSecondNameCase(CaseNumber);
        }

        /**
         * Функция ставит отчество <var>$fatherName</var> в нужный падеж <var>$CaseNumber</var> по правилам пола <var>$gender</var>.
         *
         * Если указан номер падежа <var>$CaseNumber</var>, тогда возвращается строка с таким номером падежа,
         * если нет, тогда возвращается массив со всеми падежами текущего слова.
         * @param string $fatherName отчество, которое нужно просклонять
         * @param int $CaseNumber номер падежа
         * @param int $gender пол, который нужно использовать
         * @return mixed массив или строка с нужным падежом
         */

    }, {
        key: 'qFatherName',
        value: function qFatherName(fatherName) {
            var CaseNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var gender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

            this.fullReset();
            this.setFatherName(fatherName);
            if (gender) {
                this.setGender(gender);
            }
            return this.getFatherNameCase(CaseNumber);
        }

        /**
         * Склоняет текущие слова во все падежи и форматирует слово по шаблону <var>$format</var>
         * <b>Формат:</b>
         * - S - Фамилия
         * - N - Имя
         * - F - Отчество
         * @param string $format строка формат
         * @return array массив со всеми падежами
         */

    }, {
        key: 'getFormattedArray',
        value: function getFormattedArray(format) {
            if (is_array(format)) {
                return this.getFormattedArrayHard(format);
            }

            var length = _NCLStr2.default.strlen(format);
            var result = [];
            var cases = {};
            cases['S'] = this.getCasesConnected(index['S']);
            cases['N'] = this.getCasesConnected(index['N']);
            cases['F'] = this.getCasesConnected(index['F']);

            for (var curCase = 0; curCase < this.CaseCount; curCase++) {
                var line = "";
                for (var i = 0; i < length; i++) {
                    var symbol = _NCLStr2.default.substr(format, i, 1);
                    if (symbol == 'S') {
                        line += cases['S'][curCase];
                    } else if (symbol == 'N') {
                        line += cases['N'][curCase];
                    } else if (symbol == 'F') {
                        line += cases['F'][curCase];
                    } else {
                        line += symbol;
                    }
                }
                result.push(line);
            }
            return result;
        }

        /**
         * Склоняет текущие слова во все падежи и форматирует слово по шаблону <var>$format</var>
         * <b>Формат:</b>
         * - S - Фамилия
         * - N - Имя
         * - F - Отчество
         * @param array $format массив с форматом
         * @return array массив со всеми падежами
         */

    }, {
        key: 'getFormattedArrayHard',
        value: function getFormattedArrayHard(format) {
            var result = [];
            var cases = [];
            var _iteratorNormalCompletion13 = true;
            var _didIteratorError13 = false;
            var _iteratorError13 = undefined;

            try {
                for (var _iterator13 = format[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
                    var word = _step13.value;

                    cases.push(word.getNameCases());
                }
            } catch (err) {
                _didIteratorError13 = true;
                _iteratorError13 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion13 && _iterator13.return) {
                        _iterator13.return();
                    }
                } finally {
                    if (_didIteratorError13) {
                        throw _iteratorError13;
                    }
                }
            }

            for (var curCase = 0; curCase < this.CaseCount; curCase++) {
                var line = "";
                var _iteratorNormalCompletion14 = true;
                var _didIteratorError14 = false;
                var _iteratorError14 = undefined;

                try {
                    for (var _iterator14 = cases[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
                        var value = _step14.value;

                        line += value[curCase] + ' ';
                    }
                } catch (err) {
                    _didIteratorError14 = true;
                    _iteratorError14 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion14 && _iterator14.return) {
                            _iterator14.return();
                        }
                    } finally {
                        if (_didIteratorError14) {
                            throw _iteratorError14;
                        }
                    }
                }

                result.push(trim(line));
            }
            return result;
        }

        /**
         * Склоняет текущие слова в падеж <var>$caseNum</var> и форматирует слово по шаблону <var>$format</var>
         * <b>Формат:</b>
         * - S - Фамилия
         * - N - Имя
         * - F - Отчество
         * @param array $format массив с форматом
         * @return string строка в нужном падеже
         */

    }, {
        key: 'getFormattedHard',
        value: function getFormattedHard() {
            var caseNum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

            var result = "";
            var _iteratorNormalCompletion15 = true;
            var _didIteratorError15 = false;
            var _iteratorError15 = undefined;

            try {
                for (var _iterator15 = format[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                    var word = _step15.value;

                    var cases = word.getNameCases();
                    result += cases[caseNum] + ' ';
                }
            } catch (err) {
                _didIteratorError15 = true;
                _iteratorError15 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion15 && _iterator15.return) {
                        _iterator15.return();
                    }
                } finally {
                    if (_didIteratorError15) {
                        throw _iteratorError15;
                    }
                }
            }

            return trim(result);
        }
    }, {
        key: 'getFormatted',


        /**
         * Склоняет текущие слова в падеж <var>$caseNum</var> и форматирует слово по шаблону <var>$format</var>
         * <b>Формат:</b>
         * - S - Фамилия
         * - N - Имя
         * - F - Отчество
         * @param string $format строка с форматом
         * @return string строка в нужном падеже
         */
        value: function getFormatted() {
            var caseNum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "S N F";

            this.AllWordCases();
            //Если не указан падеж используем другую функцию
            if (is_null(caseNum) || !caseNum) {
                return this.getFormattedArray(format);
            }
            //Если формат сложный
            else if (is_array(format)) {
                    return this.getFormattedHard(caseNum, format);
                } else {
                    var length = _NCLStr2.default.strlen(format);
                    var result = "";
                    for (var i = 0; i < length; i++) {
                        var symbol = _NCLStr2.default.substr(format, i, 1);
                        if (symbol == 'S') {
                            result += this.getSecondNameCase(caseNum);
                        } else if (symbol == 'N') {
                            result += this.getFirstNameCase(caseNum);
                        } else if (symbol == 'F') {
                            result += this.getFatherNameCase(caseNum);
                        } else {
                            result += symbol;
                        }
                    }
                    return result;
                }
        }

        /**
         * Склоняет фамилию <var>$secondName</var>, имя <var>$firstName</var>, отчество <var>$fatherName</var>
         * в падеж <var>$caseNum</var> по правилам пола <var>$gender</var> и форматирует результат по шаблону <var>$format</var>
         * <b>Формат:</b>
         * - S - Фамилия
         * - N - Имя
         * - F - Отчество
         * @param string $secondName фамилия
         * @param string $firstName имя
         * @param string $fatherName отчество
         * @param int $gender пол
         * @param int $caseNum номер падежа
         * @param string $format формат
         * @return mixed либо массив со всеми падежами, либо строка
         */

    }, {
        key: 'qFullName',
        value: function qFullName() {
            var secondName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var firstName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
            var fatherName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
            var gender = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            var caseNum = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
            var format = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "S N F";

            this.fullReset();
            this.setFirstName(firstName);
            this.setSecondName(secondName);
            this.setFatherName(fatherName);
            if (gender) {
                this.setGender(gender);
            }

            return this.getFormatted(caseNum, format);
        }

        /**
         * Склоняет ФИО <var>$fullname</var> в падеж <var>$caseNum</var> по правилам пола <var>$gender</var>.
         * Возвращает результат в таком же формате, как он и был.
         * @param string $fullname ФИО
         * @param int $caseNum номер падежа
         * @param int $gender пол человека
         * @return mixed либо массив со всеми падежами, либо строка
         */

    }, {
        key: 'q',
        value: function q(fullname) {
            var caseNum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var gender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

            this.fullReset();
            var format = this.splitFullName(fullname);
            if (gender) {
                this.setGender(gender);
            }

            return this.getFormatted(caseNum, format);
        }

        /**
         * Определяет пол человека по ФИО
         * @param string $fullname ФИО
         * @return int пол человека
         */

    }, {
        key: 'genderDetect',
        value: function genderDetect(fullname) {
            this.fullReset();
            this.splitFullName(fullname);
            return this.genderAutoDetect();
        }

        /**
         * Возвращает внутренний массив $this->words каждая запись имеет тип NCLNameCaseWord
         * @return array Массив всех слов в системе
         */

    }, {
        key: 'getWordsArray',
        value: function getWordsArray() {
            return this.words;
        }

        /**
         * Функция пытается применить цепочку правил для мужских имен
         * @return boolean true - если было использовано правило из списка, false - если правило не было найденым
         */

    }, {
        key: 'manFirstName',
        value: function manFirstName() {
            return false;
        }

        /**
         * Функция пытается применить цепочку правил для женских имен
         * @return boolean true - если было использовано правило из списка, false - если правило не было найденым
         */

    }, {
        key: 'womanFirstName',
        value: function womanFirstName() {
            return false;
        }

        /**
         * Функция пытается применить цепочку правил для мужских фамилий
         * @return boolean true - если было использовано правило из списка, false - если правило не было найденым
         */

    }, {
        key: 'manSecondName',
        value: function manSecondName() {
            return false;
        }

        /**
         * Функция пытается применить цепочку правил для женских фамилий
         * @return boolean true - если было использовано правило из списка, false - если правило не было найденым
         */

    }, {
        key: 'womanSecondName',
        value: function womanSecondName() {
            return false;
        }

        /**
         * Функция склоняет мужский отчества
         * @return boolean true - если слово было успешно изменено, false - если не получилось этого сделать
         */

    }, {
        key: 'manFatherName',
        value: function manFatherName() {
            return false;
        }

        /**
         * Функция склоняет женские отчества
         * @return boolean true - если слово было успешно изменено, false - если не получилось этого сделать
         */

    }, {
        key: 'womanFatherName',
        value: function womanFatherName() {
            return false;
        }

        /**
         * Определение пола по правилам имен
         * @param NCLNameCaseWord $word обьект класса слов, для которого нужно определить пол
         */

    }, {
        key: 'GenderByFirstName',
        value: function GenderByFirstName( /*NCLNameCaseWord*/word) {
            if (!(word instanceof _NCLNameCaseWord2.default)) throw new Exception("word should be of class NCLNameCaseWord");
        }

        /**
         * Определение пола по правилам фамилий
         * @param NCLNameCaseWord $word обьект класса слов, для которого нужно определить пол
         */

    }, {
        key: 'GenderBySecondName',
        value: function GenderBySecondName( /*NCLNameCaseWord*/word) {
            if (!(word instanceof _NCLNameCaseWord2.default)) throw new Exception("word should be of class NCLNameCaseWord");
        }

        /**
         * Определение пола по правилам отчеств
         * @param NCLNameCaseWord $word обьект класса слов, для которого нужно определить пол
         */

    }, {
        key: 'GenderByFatherName',
        value: function GenderByFatherName( /*NCLNameCaseWord*/word) {
            if (!(word instanceof _NCLNameCaseWord2.default)) throw new Exception("word should be of class NCLNameCaseWord");
        }

        /**
         * Идетифицирует слово определяе имя это, или фамилия, или отчество
         * - <b>N</b> - имя
         * - <b>S</b> - фамилия
         * - <b>F</b> - отчество
         * @param NCLNameCaseWord $word обьект класса слов, который необходимо идентифицировать
         */

    }, {
        key: 'detectNamePart',
        value: function detectNamePart( /*NCLNameCaseWord*/word) {
            if (!(word instanceof _NCLNameCaseWord2.default)) throw new Exception("word should be of class NCLNameCaseWord");
        }

        /**
         * Возвращает версию библиотеки
         * @return string версия библиотеки
         */

    }, {
        key: 'version',
        value: function version() {
            return this._version;
        }

        /**
         * Возвращает версию использованого языкового файла
         * @return string версия языкового файла
         */

    }, {
        key: 'languageVersion',
        value: function languageVersion() {
            return this._languageBuild;
        }
    }]);

    return NCLNameCaseCore;
}(_NCL3.default);

exports.default = NCLNameCaseCore;